# LingoGo 项目规则

## 国际化 (i18n) 硬性规则

**所有用户可见的文本必须使用国际化 (i18n)，禁止硬编码任何文本字符串。**

### 具体要求：

1. **禁止硬编码文本**：所有在 UI 中显示的文本（包括按钮、标签、提示信息、错误消息等）必须通过 i18n 系统获取，不能直接使用字符串字面量。

2. **支持的语言**：项目必须支持以下语言：
   - 中文简体 (zh-CN)
   - 英文 (en-US)
   - 日文 (ja-JP)

3. **实现方式**：
   - 使用 Flutter 的 `intl` 包或项目自定义的 i18n 方案
   - 所有文本必须从翻译资源文件中获取
   - 根据 `UserSettingsModel` 中的 `uiLanguage` 字段动态切换语言

4. **代码审查检查点**：
   - 检查所有 `Text()` widget 中的字符串是否使用了 i18n
   - 检查所有 `AppBar`、`Button`、`Dialog` 等组件中的文本
   - 检查所有错误提示、成功提示等消息文本
   - 检查所有占位符文本（placeholder）

5. **例外情况**：
   - 仅用于调试的日志输出可以使用硬编码文本
   - 代码注释可以使用任何语言
   - 技术性的配置值、API 端点等可以使用硬编码

### 示例：

❌ **错误示例**：
```dart
Text('欢迎使用 lingoGO')
ElevatedButton(
  child: Text('下一步'),
  ...
)
```

✅ **正确示例**：
```dart
Text(S.of(context).welcomeTitle)
ElevatedButton(
  child: Text(S.of(context).nextButton),
  ...
)
```

---

## 代码封装与设计模式规则

**代码应该遵循良好的封装原则，并在合适的场景下使用设计模式来提高代码质量和可维护性。**

### 封装原则：

1. **单一职责原则**：每个类、函数或模块应该只负责一个明确的功能。
   - 避免在同一个类中混合多种不相关的功能
   - 将复杂功能拆分为多个独立的类或函数

2. **功能模块化**：
   - 将可复用的功能封装成独立的类或工具类
   - 原生平台代码（Android/iOS）中的功能应该封装成独立的类，而不是直接写在 MainActivity 或 AppDelegate 中
   - 业务逻辑应该与 UI 层分离

3. **接口抽象**：
   - 使用接口或抽象类来定义契约，而不是直接依赖具体实现
   - 通过依赖注入来降低模块间的耦合

4. **信息隐藏**：
   - 使用 private/protected 修饰符来隐藏内部实现细节
   - 只暴露必要的公共接口

### 设计模式使用场景：

1. **单例模式 (Singleton)**：
   - 适用于需要全局唯一实例的场景（如配置管理、日志管理、数据库连接等）
   - 注意线程安全

2. **工厂模式 (Factory)**：
   - 适用于需要根据条件创建不同类型对象的场景
   - 适用于复杂对象的创建逻辑封装

3. **观察者模式 (Observer)**：
   - 适用于事件通知、状态变化监听等场景
   - Flutter 中可以使用 Stream、ValueNotifier 等

4. **策略模式 (Strategy)**：
   - 适用于需要动态切换算法或行为的场景
   - 例如：不同的支付方式、不同的数据处理策略

5. **适配器模式 (Adapter)**：
   - 适用于需要适配不同接口的场景
   - 例如：第三方 SDK 的封装、不同平台 API 的统一接口

6. **建造者模式 (Builder)**：
   - 适用于需要创建复杂对象的场景
   - 例如：复杂的配置对象、请求参数构建

7. **依赖注入 (Dependency Injection)**：
   - 通过构造函数或方法参数注入依赖，而不是在类内部直接创建
   - 提高代码的可测试性和灵活性

### 代码组织建议：

1. **目录结构**：
   - 按功能模块组织代码
   - 将相关的类放在同一个包/目录下
   - 工具类和辅助类应该放在专门的 utils/helpers 目录

2. **命名规范**：
   - 类名使用大驼峰命名（PascalCase）
   - 方法名和变量名使用小驼峰命名（camelCase）
   - 常量使用全大写下划线分隔（UPPER_SNAKE_CASE）

3. **代码复用**：
   - 避免重复代码（DRY 原则）
   - 将公共逻辑提取到基类或工具类中
   - 使用组合而不是继承来复用代码

### 示例：

❌ **错误示例**：功能直接写在 MainActivity 中
```java
public class MainActivity extends FlutterActivity {
    private void extractAudio(...) {
        // 大量音频提取逻辑直接写在这里
    }
}
```

✅ **正确示例**：功能封装成独立类
```java
// AudioExtractor.java - 独立的音频提取类
public class AudioExtractor {
    public static String extractAudio(...) {
        // 音频提取逻辑
    }
}

// MainActivity.java - 只负责调用
public class MainActivity extends FlutterActivity {
    private void extractAudio(...) {
        AudioExtractor.extractAudio(...);
    }
}
```

---

## 其他规则

- 不需要生成测试代码
- 在没有要求的时候，也不要生成文档来说明
- 日志打印使用项目封装的 Log 类，注意查看用法
- 始终使用中文回复
