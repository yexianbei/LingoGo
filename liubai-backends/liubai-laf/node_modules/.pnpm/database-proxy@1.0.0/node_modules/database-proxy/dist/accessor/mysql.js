"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MysqlAccessor = void 0;
const types_1 = require("../types");
const promise_1 = require("mysql2/promise");
const sql_builder_1 = require("./sql_builder");
const __1 = require("..");
const events_1 = require("events");
/**
 * Mysql Accessor
 */
class MysqlAccessor {
    get logger() {
        if (!this._logger) {
            this._logger = new __1.DefaultLogger();
        }
        return this._logger;
    }
    setLogger(logger) {
        this._logger = logger;
    }
    get conn() {
        return this.pool;
    }
    constructor(options) {
        this.type = 'mysql';
        this._event = new events_1.EventEmitter();
        this.db_name = options.database;
        this.options = options;
        this.pool = (0, promise_1.createPool)(options);
        this.logger.info(`mysql accessor init`);
    }
    emit(event, ...args) {
        return this._event.emit(event, ...args);
    }
    once(event, listener) {
        this.once(event, listener);
    }
    removeAllListeners(event) {
        this._event.removeAllListeners(event);
    }
    on(event, listener) {
        this._event.on(event, listener);
    }
    off(event, listener) {
        this._event.off(event, listener);
    }
    async close() {
        await this.conn.end();
        this.logger.info('mysql connection closed');
    }
    async execute(params) {
        const { collection, action } = params;
        this.logger.info(`mysql start executing {${collection}}: ` + JSON.stringify(params));
        if (action === types_1.ActionType.READ) {
            return await this.read(collection, params);
        }
        if (action === types_1.ActionType.UPDATE) {
            return await this.update(collection, params);
        }
        if (action === types_1.ActionType.ADD) {
            return await this.add(collection, params);
        }
        if (action === types_1.ActionType.REMOVE) {
            return await this.remove(collection, params);
        }
        if (action === types_1.ActionType.COUNT) {
            return await this.count(collection, params);
        }
        const error = `invalid 'action': ${action}`;
        this.logger.error(`mysql end of executing occurred:` + error);
        throw new Error(error);
    }
    async get(collection, query) {
        const params = {
            collection: collection,
            action: types_1.ActionType.READ,
            query: query,
            limit: 1,
        };
        const { sql, values } = sql_builder_1.SqlBuilder.from(params).select();
        const [rows] = await this.conn.execute(sql, values);
        return rows.length ? rows[0] : null;
    }
    async read(_collection, params) {
        var _a;
        const { collection } = params;
        const { sql, values } = sql_builder_1.SqlBuilder.from(params).select();
        const nestTables = (_a = params.nested) !== null && _a !== void 0 ? _a : false;
        this.logger.debug(`mysql read {${collection}}: `, { sql, values });
        const [rows] = await this.conn.execute({
            sql,
            values,
            nestTables,
        });
        return {
            list: rows,
        };
    }
    async update(_collection, params) {
        const { collection } = params;
        const { sql, values } = sql_builder_1.SqlBuilder.from(params).update();
        this.logger.debug(`mysql update {${collection}}: `, { sql, values });
        const [ret] = await this.conn.execute(sql, values);
        return {
            updated: ret.affectedRows,
            matched: ret.affectedRows,
            upsert_id: undefined,
        };
    }
    async add(_collection, params) {
        const { multi, collection } = params;
        if (multi) {
            console.warn('mysql add(): {multi == true} has been ignored!');
        }
        const { sql, values } = sql_builder_1.SqlBuilder.from(params).insert();
        this.logger.debug(`mysql add {${collection}}: `, { sql, values });
        const [ret] = await this.conn.execute(sql, values);
        return {
            _id: ret.insertId,
            insertedCount: ret.affectedRows,
        };
    }
    async remove(_collection, params) {
        const { collection } = params;
        const { sql, values } = sql_builder_1.SqlBuilder.from(params).delete();
        this.logger.debug(`mysql remove {${collection}}: `, { sql, values });
        const [ret] = await this.conn.execute(sql, values);
        return {
            deleted: ret.affectedRows,
        };
    }
    async count(_collection, params) {
        const { collection } = params;
        const { sql, values } = sql_builder_1.SqlBuilder.from(params).count();
        this.logger.debug(`mysql count {${collection}}: `, { sql, values });
        const [ret] = await this.conn.execute(sql, values);
        if (ret.length === 0) {
            return { total: 0 };
        }
        return {
            total: ret[0].total,
        };
    }
}
exports.MysqlAccessor = MysqlAccessor;
